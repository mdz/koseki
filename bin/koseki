#!/usr/bin/env ruby

require "irb"
require "irb/completion"

require 'fog'
require 'sequel'
require 'amazon-pricing'

class Koseki
  def initialize
    @db = Sequel.connect(ENV['DATABASE_URL'])
    @regions = nil
  end

  def poll_all_clouds
    for cloud in clouds
      poll_cloud(cloud)
    end
  end

  def clouds
    @db[:clouds].all
  end

  def poll_cloud(cloud)
    cloud_name = cloud[:name]
    puts "cloud=#{cloud_name} at=starting"

    # Connect to the default region and get the list of available regions
    if @regions == nil
      @regions = Fog::Compute.new({:provider => 'AWS',
            :aws_access_key_id => cloud[:access_key_id],
            :aws_secret_access_key => cloud[:secret_access_key]})
            .describe_regions.body["regionInfo"].map {|region| region["regionName"]}
    end

    for region in @regions
      puts "cloud=#{cloud[:name]} region=#{region} at=starting"
      compute = Fog::Compute.new({:provider => 'AWS',
        :region => region,
        :aws_access_key_id => cloud[:access_key_id],
        :aws_secret_access_key => cloud[:secret_access_key]
      })

      # discover availability zones and their mappings across accounts
      # http://alestic.com/2009/07/ec2-availability-zones

      begin
        for availability_zone in compute.describe_availability_zones.body["availabilityZoneInfo"]
          logical_az = availability_zone["zoneName"]

          # check if we already have a mapping for this AZ
          next if @db[:availability_zone_mappings].where(:cloud_id => cloud[:id], :logical_az => logical_az).count > 0

          # find its key via reserved instance offerings
          offerings = compute.describe_reserved_instances_offerings({
            'instance-type' => 'm1.small',
            'product-description' => 'Linux/UNIX',
            'duration' => 31536000,
            'availability-zone' => logical_az
          }).body["reservedInstancesOfferingsSet"].select {|r| r["offeringType"] == "Medium Utilization"}

          if offerings.length == 0
            puts "cloud=#{cloud_name} region=#{region} at=error error=\"can't determine AZ mapping (no RIs available for #{logical_az}?)\""
            next
          elsif offerings.length > 1
            # Probably AWS has added new criteria and we need a tighter filter above
            puts "cloud=#{cloud_name} region=#{region} at=error error=\"can't determine AZ mapping (multiple matches for #{logical_az})\""
            next
          end

          key = offerings.first["reservedInstancesOfferingId"]

          # check if we've seen another AZ with the same key
          matching = @db[:availability_zones].where({:key => key})
          if matching.count > 0
            # we've seen it before on another cloud, so copy the physical name from there
            availability_zone_id = matching.first[:id]
          else
            # globally new AZ
            @db[:availability_zones].insert(
              :name => "unknown-#{SecureRandom.uuid}",
              :key => key,
              :region => region,
            )
            availability_zone_id = @db[:availability_zones].where({:key => key}).first[:id]
          end

          @db[:availability_zone_mappings].insert(
            :cloud_id => cloud[:id],
            :logical_az => logical_az,
            :availability_zone_id => availability_zone_id,
          )
        end
      rescue Fog::Compute::AWS::Error => err
        puts "cloud=#{cloud_name} region=#{region} at=error error=\"can't determine AZ mapping (no permission)\""
      end

      num_reservations = 0
      new_reservations = 0
      for ri in compute.describe_reserved_instances.body["reservedInstancesSet"]
        if @db[:reservations].where(:id => ri["reservedInstancesId"]).count == 0
          @db[:reservations].insert(
            :id => ri["reservedInstancesId"],
            :cloud_id => cloud[:id],
            :availability_zone => ri["availabilityZone"],
            :instance_type => ri["instanceType"],
            :instance_count => ri["instanceCount"],
            :start => ri["start"],
            :duration_seconds => ri["duration"],
            :offering_type => ri["offeringType"],
          )
          new_reservations += 1
        end
        num_reservations += 1
      end

      num_servers = 0
      new_servers = 0
      now = Time.now
      for i in compute.servers
        existing = @db[:instances].where(:instance_id => i.id)
        if existing.count > 0
          existing.update(:last_seen => now)
        else
          @db[:instances].insert(
            :cloud_id => cloud[:id],
            :instance_id => i.id,
            :availability_zone => i.availability_zone,
            :instance_type => i.flavor_id,
            :created_at => i.created_at,
            :last_seen => now,
          )
          new_servers += 1
        end
        num_servers += 1
      end
    end

    puts "cloud=#{cloud_name} region=#{region} at=finished num_servers=#{num_servers} new_servers=#{new_servers} num_reservations=#{num_reservations} new_reservations=#{new_reservations}"
  end

  def import_pricelist
    regionmap = {
      "us-east" => "us-east-1",
      "apac-tokyo" => "ap-northeast-1",
      "sa-east-1" => "sa-east-1",
      "apac-sin" => "ap-southeast-1",
      "us-west-2" => "us-west-2",
      "us-west" => "us-west-1",
      "eu-ireland" => "eu-west-1"
    }

    price_list = AwsPricing::PriceList.new

    for region in price_list.regions
      for instance_type in region.ec2_on_demand_instance_types
        @db[:instance_ondemand_pricing].insert(
          :region => regionmap[region.name], :instance_type => instance_type.api_name,
          :price => instance_type.linux_price_per_hour * 1000
        )
      end
    end
  end

  def initdb
    @db.create_table :clouds do
      primary_key :id
      String :name, :unique => true
      String :access_key_id, :null => false
      String :secret_access_key, :null => false
    end

    @db.create_table :availability_zone_mappings do
      foreign_key :cloud_id, :clouds
      String :logical_az, :null => false
      Integer :availability_zone_id, :null => false
      unique ([:cloud_id, :logical_az])
    end

    @db.create_table :availability_zones do
      primary_key :id
      String :name, :unique => true
      String :key, :unique => true
      String :region, :null => false
    end

    @db.create_table :reservations do
      String :id, :primary_key => true
      foreign_key :cloud_id, :clouds
      String :availability_zone, :null => false
      String :instance_type, :null => false
      Integer :instance_count, :null => false
      String :offering_type, :null => false
      DateTime :start, :null => false
      Integer :duration_seconds, :null => false
    end

    @db.create_table :instances do
      foreign_key :cloud_id, :clouds
      String :instance_id, :null => false
      DateTime :last_seen, :null => false
      String :availability_zone, :null => false
      String :instance_type, :null => false
      DateTime :created_at, :null => false
    end

    @db.create_table :instance_ondemand_pricing do
      String :instance_type, :null => false
      String :region, :null => false
      Integer :price, :null => false
      unique ([:instance_type, :region])
    end

  end
end

case ARGV.first
when 'console'
  IRB.start
when 'poll'
  Koseki.new.poll_all_clouds
when 'get-prices'
  Koseki.new.import_pricelist
when 'initdb'
  Koseki.new.initdb
end
