#!/usr/bin/env ruby

$:.unshift(File.expand_path(File.join(File.dirname(File.dirname($0)), "lib")))

require "irb"
require "irb/completion"

require 'fog'
require 'sequel'
require 'amazon-pricing'
require 'koseki/autoload'

class Controller
  def initialize
    @db = Sequel.connect(ENV['DATABASE_URL'])
    @db.extension :pg_hstore
  end

  def poll_clouds(cloud_names=nil)
    for cloud in clouds
      next if cloud_names and not cloud_names.empty? and not cloud_names.include? cloud.name

      puts "cloud=#{cloud.name} at=start"
      for region in cloud.regions
        puts "cloud=#{cloud.name} region=#{region.name} at=start"
        region.refresh_all
        puts "cloud=#{cloud.name} region=#{region.name} at=finish"
      end
      puts "cloud=#{cloud.name} at=finish"
    end
  end

  def clouds
    Koseki::Cloud.all
  end

  def import_pricelist
    regionmap = {
      "us-east" => "us-east-1",
      "apac-tokyo" => "ap-northeast-1",
      "sa-east-1" => "sa-east-1",
      "apac-sin" => "ap-southeast-1",
      "us-west-2" => "us-west-2",
      "us-west" => "us-west-1",
      "eu-ireland" => "eu-west-1"
    }

    price_list = AwsPricing::PriceList.new

    Koseki::InstanceOndemandPrice.delete
    Koseki::InstanceReservedPrice.delete

    for region in price_list.regions
      for instance_type in region.ec2_on_demand_instance_types
        Koseki::InstanceOndemandPrice.find_or_create(
          :region => regionmap[region.name],
          :instance_type => instance_type.api_name
        ) do |iop|
          iop.region = regionmap[region.name]
          iop.instance_type = instance_type.api_name
          iop.price = instance_type.linux_price_per_hour * 1000
        end
      end
      for instance_type in region.ec2_reserved_instance_types(:medium)
        next unless instance_type.prepay_1_year and instance_type.linux_price_per_hour_1_year

        irp = Koseki::InstanceReservedPrice.find_or_create(
          :region => regionmap[region.name],
          :instance_type => instance_type.api_name
        ) do |irp|
          irp.region = regionmap[region.name]
          irp.instance_type = instance_type.api_name
          irp.price_upfront = instance_type.prepay_1_year.to_f * 1000
          irp.price_per_hour = instance_type.linux_price_per_hour_1_year.to_f * 1000
        end
      end
    end
  end

  def unknown_azs
    @db["SELECT clouds.name AS cloud, instances.availability_zone, count(*) from instances INNER JOIN clouds ON clouds.id = instances.cloud_id left join availability_zone_mappings on (instances.availability_zone = availability_zone_mappings.logical_az and availability_zone_mappings.cloud_id = instances.cloud_id) where availability_zone_mappings.availability_zone_id is null group by clouds.name, instances.availability_zone"]
  end

  def initdb
    @db.create_table :clouds do
      primary_key :id
      String :name, :unique => true
      String :access_key_id, :null => false
      String :secret_access_key, :null => false
    end

    @db.create_table :availability_zones do
      primary_key :id
      String :name, :unique => true
      String :key, :unique => true
      String :region, :null => false
    end

    @db.create_table :availability_zone_mappings do
      foreign_key :cloud_id, :clouds
      String :logical_az, :null => false
      foreign_key :az_id, :availability_zones
      unique ([:cloud_id, :logical_az])
    end

    @db.create_table :reservations do
      String :id, :unique => true, :null => false
      foreign_key :cloud_id, :clouds
      String :logical_az, :null => false
      foreign_key :az_id, :availability_zones
      String :instance_type, :null => false
      Integer :instance_count, :null => false
      String :offering_type, :null => false
      DateTime :start, :null => false
      Integer :duration_seconds, :null => false
    end

    @db.create_table :instances do
      primary_key :id
      foreign_key :cloud_id, :clouds
      String :instance_id, :null => false
      DateTime :last_seen, :null => false
      Boolean :running, :null => false
      String :region, :null => false
      String :logical_az, :null => false
      foreign_key :az_id, :availability_zones
      String :instance_type, :null => false
      String :private_ip_address
      String :public_ip_address
      DateTime :created_at, :null => false
      HStore :tags
    end

    @db.create_table :instance_ondemand_prices do
      String :instance_type, :null => false
      String :region, :null => false
      Integer :price, :null => false
      unique ([:instance_type, :region])
    end

    @db.create_table :instance_reserved_prices do
      String :instance_type, :null => false
      String :region, :null => false
      Integer :price_upfront, :null => false
      Integer :price_per_hour, :null => false
      unique ([:instance_type, :region])
    end

    @db.create_table :volumes do
      primary_key :id
      String :volume_id, :null => false, :unique => true
      foreign_key :cloud_id, :clouds
      String :region, :null => false
      String :logical_az, :null => false
      foreign_key :az_id, :availability_zones
      DateTime :created_at, :null => false
      DateTime :last_seen, :null => false
      String :server_id
      Boolean :active, :null => false
      Integer :size, :null => false
      HStore :tags
    end

  end
end

case ARGV.first
when 'console'
  $controller = Controller.new
  ARGV.clear
  IRB.start
when 'poll'
  Controller.new.poll_clouds(ARGV[1..-1])
when 'get-prices'
  Controller.new.import_pricelist
when 'initdb'
  Controller.new.initdb
when 'unknown-azs'
  for az in Controller.new.unknown_azs
    puts az
  end
when 'migrate-db'
  system 'sequel', '-m', 'migrations', ENV['DATABASE_URL']
else
  raise "Unknown command"
end
