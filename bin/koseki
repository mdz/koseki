#!/usr/bin/env ruby

$:.unshift(File.expand_path(File.join(File.dirname(File.dirname($0)), "lib")))

require "irb"
require "irb/completion"

require 'fog'
require 'sequel'
require 'amazon-pricing'
require 'koseki/autoload'

class Controller
  def initialize
    @db = Sequel.connect(ENV['DATABASE_URL'])
    @regions = nil
  end

  def poll_all_clouds
    for cloud in clouds
      poll_cloud(cloud)
    end
  end

  def clouds
    Koseki::Cloud.all
  end

  def poll_cloud(cloud)
    puts "cloud=#{cloud.name} at=starting"

    # Connect to the default region and get the list of available regions
    if @regions == nil
      @regions = Fog::Compute.new({:provider => 'AWS',
            :aws_access_key_id => cloud.access_key_id,
            :aws_secret_access_key => cloud.secret_access_key})
            .describe_regions.body["regionInfo"].map {|region| region["regionName"]}
    end

    for region in @regions
      puts "cloud=#{cloud.name} region=#{region} at=starting"
      compute = Fog::Compute.new({:provider => 'AWS',
        :region => region,
        :aws_access_key_id => cloud.access_key_id,
        :aws_secret_access_key => cloud.secret_access_key
      })

      # discover availability zones and their mappings across accounts
      # http://alestic.com/2009/07/ec2-availability-zones

      for availability_zone in compute.describe_availability_zones.body["availabilityZoneInfo"]
        logical_az = availability_zone["zoneName"]

        begin
          Koseki::AvailabilityZoneMapping.find_or_create(
            :cloud_id => cloud.id,
            :logical_az => logical_az
          ) do |azm|
            # find its key via reserved instance offerings
            offerings = compute.describe_reserved_instances_offerings({
              'instance-type' => 'm1.small',
              'product-description' => 'Linux/UNIX',
              'duration' => 31536000,
              'availability-zone' => logical_az
            }).body["reservedInstancesOfferingsSet"].select {|r| r["offeringType"] == "Medium Utilization"}

            if offerings.length == 0
              raise "no RIs available"
            elsif offerings.length > 1
              # Probably AWS has added new criteria and we need a tighter filter above
              raise "multiple matches"
            end

            key = offerings.first["reservedInstancesOfferingId"]

            az = Koseki::AvailabilityZone.find_or_create(:key => key) do |az|
              az.name = "unknown-#{SecureRandom.uuid}"
              az.key = key
              az.region = region
            end

            azm.cloud_id = cloud.id
            azm.logical_az = logical_az
            azm.availability_zone_id = az.id
          end
        rescue RuntimeError => err
          puts "cloud=#{cloud.name} region=#{region} at=error error=\"Can't determine AZ mapping for #{logical_az}: #{err}\""
          next
        end
      end

      num_reservations = 0
      new_reservations = 0
      for ri in compute.describe_reserved_instances.body["reservedInstancesSet"]
        Koseki::Reservation.find_or_create(:id => ri["reservedInstancesId"]) do |r|
          r.id = ri["reservedInstancesId"]
          r.cloud_id = cloud.id
          r.availability_zone = ri["availabilityZone"]
          r.instance_type = ri["instanceType"]
          r.instance_count = ri["instanceCount"]
          r.start = ri["start"]
          r.duration_seconds = ri["duration"]
          r.offering_type = ri["offeringType"]
          new_reservations += 1
        end
        num_reservations += 1
      end

      num_servers = 0
      new_servers = 0
      now = Time.now
      for i in compute.servers
        existing = @db[:instances].where(:instance_id => i.id)
        if existing.count > 0
          existing.update(:last_seen => now)
        else
          @db[:instances].insert(
            :cloud_id => cloud.id,
            :instance_id => i.id,
            :availability_zone => i.availability_zone,
            :instance_type => i.flavor_id,
            :created_at => i.created_at,
            :last_seen => now,
          )
          new_servers += 1
        end
        num_servers += 1
      end

      puts "cloud=#{cloud.name} region=#{region} at=finished num_servers=#{num_servers} new_servers=#{new_servers} num_reservations=#{num_reservations} new_reservations=#{new_reservations}"
    end

    puts "cloud=#{cloud.name} at=finished"
  end

  def import_pricelist
    regionmap = {
      "us-east" => "us-east-1",
      "apac-tokyo" => "ap-northeast-1",
      "sa-east-1" => "sa-east-1",
      "apac-sin" => "ap-southeast-1",
      "us-west-2" => "us-west-2",
      "us-west" => "us-west-1",
      "eu-ireland" => "eu-west-1"
    }

    price_list = AwsPricing::PriceList.new

    for region in price_list.regions
      for instance_type in region.ec2_on_demand_instance_types
        @db[:instance_ondemand_pricing].insert(
          :region => regionmap[region.name], :instance_type => instance_type.api_name,
          :price => instance_type.linux_price_per_hour * 1000
        )
      end
    end
  end

  def initdb
    @db.create_table :clouds do
      primary_key :id
      String :name, :unique => true
      String :access_key_id, :null => false
      String :secret_access_key, :null => false
    end

    @db.create_table :availability_zone_mappings do
      foreign_key :cloud_id, :clouds
      String :logical_az, :null => false
      Integer :availability_zone_id, :null => false
      unique ([:cloud_id, :logical_az])
    end

    @db.create_table :availability_zones do
      primary_key :id
      String :name, :unique => true
      String :key, :unique => true
      String :region, :null => false
    end

    @db.create_table :reservations do
      String :id, :unique => true, :null => false
      foreign_key :cloud_id, :clouds
      String :availability_zone, :null => false
      String :instance_type, :null => false
      Integer :instance_count, :null => false
      String :offering_type, :null => false
      DateTime :start, :null => false
      Integer :duration_seconds, :null => false
    end

    @db.create_table :instances do
      foreign_key :cloud_id, :clouds
      String :instance_id, :null => false
      DateTime :last_seen, :null => false
      String :availability_zone, :null => false
      String :instance_type, :null => false
      DateTime :created_at, :null => false
    end

    @db.create_table :instance_ondemand_pricing do
      String :instance_type, :null => false
      String :region, :null => false
      Integer :price, :null => false
      unique ([:instance_type, :region])
    end

  end
end

case ARGV.first
when 'console'
  controller = Controller.new
  ARGV.clear
  IRB.start
when 'poll'
  Controller.new.poll_all_clouds
when 'get-prices'
  Controller.new.import_pricelist
when 'initdb'
  Controller.new.initdb
else
  raise "Unknown command"
end
