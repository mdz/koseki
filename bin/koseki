#!/usr/bin/env ruby

$:.unshift(File.expand_path(File.join(File.dirname(File.dirname($0)), "lib")))

require "irb"
require "irb/completion"

require 'fog'
require 'sequel'
require 'amazon-pricing'

require 'yaml'

class Controller
  def initialize
    @db = Sequel.connect(ENV['DATABASE_URL'])
    @db.extension :pg_hstore
    STDOUT.sync = true

    # Load models after connecting to the database
    require "koseki/cloud"
    require "koseki/reservation"
    require "koseki/availability_zone"
    require "koseki/availability_zone_mapping"
    require "koseki/instance"
    require "koseki/volume"
    require "koseki/instance_reserved_price"
    require "koseki/instance_ondemand_price"
    require "koseki/ebs_price"
    require "koseki/aws_bill"
    require "koseki/aws_bill_line_item"
    require 'koseki/web'
  end

  def poll_clouds(cloud_names=nil)
    puts "fn=poll_clouds at=start"
    for cloud in clouds
      next if cloud_names and not cloud_names.empty? and not cloud_names.include? cloud.name

      poll_cloud cloud
    end
    puts "fn=poll_clouds at=finish"
  end

  def poll_cloud(cloud=nil)
    puts "fn=poll_cloud cloud=#{cloud ? cloud.name : nil} at=start"

    if cloud
      cloud.lock
    else
      while not cloud
        # find the least recently updated cloud
        Koseki::Cloud.order(Sequel.asc(:updated_at, :nulls=>:first)).each do |c|
          if c.try_lock
            cloud = c
            break
          end
        end
        break if cloud
        # all clouds are busy
        puts "fn=poll_cloud at=idle"
        sleep 1+rand(4)
      end
    end

    begin
      cloud.refresh_all
    rescue Fog::Compute::AWS::Error => err
      puts "fn=poll_cloud cloud=#{cloud.name} at=failed aws_error=#{err}"
    ensure
      cloud.unlock
    end

    puts "fn=poll_cloud cloud=#{cloud.name} at=finish"
  end

  def poll_forever
    puts "fn=poll_forever at=start"
    loops = 0
    while true
      puts "fn=poll_forever at=next loops=#{loops}"
      poll_cloud
      loops += 1
      sleep 5
    end
  end

  def clouds
    Koseki::Cloud.all
  end

  def import_pricelist
    regionmap = {
      "us-east" => "us-east-1",
      "apac-tokyo" => "ap-northeast-1",
      "sa-east-1" => "sa-east-1",
      "apac-sin" => "ap-southeast-1",
      "us-west-2" => "us-west-2",
      "us-west" => "us-west-1",
      "eu-ireland" => "eu-west-1",
      "apac-syd" => "ap-southeast-2",
      "ap-southeast-2" => "ap-southeast-2"
    }

    price_list = AwsPricing::PriceList.new

    Koseki::InstanceOndemandPrice.delete
    Koseki::InstanceReservedPrice.delete

    for region in price_list.regions
      if not regionmap.has_key? region.name
        raise "Unknown region: #{region.name}"
      end
      for instance_type in region.ec2_on_demand_instance_types
        Koseki::InstanceOndemandPrice.find_or_create(
          :region => regionmap[region.name],
          :instance_type => instance_type.api_name
        ) do |iop|
          iop.region = regionmap[region.name]
          iop.instance_type = instance_type.api_name
          iop.price = instance_type.linux_price_per_hour * 1000
        end
      end
      for instance_type in region.ec2_reserved_instance_types(:medium)
        next unless instance_type.prepay_1_year and instance_type.linux_price_per_hour_1_year

        irp = Koseki::InstanceReservedPrice.find_or_create(
          :region => regionmap[region.name],
          :instance_type => instance_type.api_name
        ) do |irp|
          irp.region = regionmap[region.name]
          irp.instance_type = instance_type.api_name
          irp.price_upfront = instance_type.prepay_1_year.to_f * 1000
          irp.price_per_hour = instance_type.linux_price_per_hour_1_year.to_f * 1000
        end
      end
      ebs = Koseki::EBSPrice.find_or_create(
        :region => regionmap[region.name]
      ) do |ebs|
        ebs.standard_per_gb = region.ebs_price.standard_per_gb * 1000
        ebs.standard_per_million_io = region.ebs_price.standard_per_million_io * 1000
        ebs.preferred_per_gb = region.ebs_price.preferred_per_gb * 1000 rescue nil
        ebs.preferred_per_iops = region.ebs_price.preferred_per_iops * 1000 rescue nil
        ebs.s3_snaps_per_gb = region.ebs_price.s3_snaps_per_gb * 1000
      end
    end
  end

  def sync_devclouds
    yaml = YAML.load(STDIN)
    yaml.each do |cloud, params|
      next unless params.include? :ion_readonly_access_key_id and \
                  params.include? :ion_readonly_secret_access_key and \
                  params.include? :name

      Koseki::Cloud.find_or_create(
        :name => params[:name]
      ) do |cloud|
        cloud.name = params[:name]
        cloud.access_key_id = params[:ion_readonly_access_key_id]
        cloud.secret_access_key = params[:ion_readonly_secret_access_key]
        puts "Adding: #{params[:name]}"
      end
    end
  end

  def web
    Koseki::Web.run! 
  end

  def migratedb
    system 'sequel', '-m', 'migrations', ENV['DATABASE_URL']
  end

  def initdb
    @db.create_table :clouds do
      primary_key :id
      String :name, :unique => true
      String :account_number, :unique => true
      String :access_key_id, :null => false
      String :secret_access_key, :null => false
      String :programmatic_billing_bucket
      DateTime :updated_at
    end

    @db.create_table :availability_zones do
      primary_key :id
      String :name, :unique => true
      String :key, :unique => true
      String :region, :null => false
    end

    @db.create_table :availability_zone_mappings do
      foreign_key :cloud_id, :clouds
      String :logical_az, :null => false
      foreign_key :az_id, :availability_zones
      unique ([:cloud_id, :logical_az])
    end

    @db.create_table :reservations do
      String :id, :unique => true, :null => false
      foreign_key :cloud_id, :clouds
      String :region, :null => false
      String :logical_az, :null => false
      foreign_key :az_id, :availability_zones
      String :instance_type, :null => false
      Integer :instance_count, :null => false
      String :offering_type, :null => false
      DateTime :start_time, :null => false
      Integer :duration, :null => false
      DateTime :end_time, :null => false
      Integer :fixed_price, :null => false
      Integer :usage_price, :null => false
      DateTime :last_seen, :null => false
    end

    @db.create_table :instances do
      primary_key :id
      foreign_key :cloud_id, :clouds
      String :instance_id, :null => false
      DateTime :last_seen, :null => false
      Boolean :running, :null => false
      String :region, :null => false
      String :logical_az, :null => false
      foreign_key :az_id, :availability_zones
      String :instance_type, :null => false
      String :private_ip_address
      String :public_ip_address
      String :reservation_id
      DateTime :created_at, :null => false
      HStore :tags
    end

    @db.create_table :instance_ondemand_prices do
      String :instance_type, :null => false
      String :region, :null => false
      Integer :price, :null => false
      unique ([:instance_type, :region])
    end

    @db.create_table :instance_reserved_prices do
      String :instance_type, :null => false
      String :region, :null => false
      Integer :price_upfront, :null => false
      Integer :price_per_hour, :null => false
      unique ([:instance_type, :region])
    end

    @db.create_table :volumes do
      primary_key :id
      String :volume_id, :null => false, :unique => true
      foreign_key :cloud_id, :clouds
      String :region, :null => false
      String :logical_az, :null => false
      foreign_key :az_id, :availability_zones
      DateTime :created_at, :null => false
      DateTime :last_seen, :null => false
      String :server_id
      Boolean :active, :null => false
      Integer :size, :null => false
      HStore :tags
    end

    @db.create_table :ebs_prices do
      String :region, :null => false
      Integer :standard_per_gb
      Integer :standard_per_million_io
      Integer :preferred_per_gb
      Integer :preferred_per_million_io
      Integer :preferred_per_iops
      Integer :s3_snaps_per_gb
    end

    @db.create_table :aws_bills do
      primary_key :id
      foreign_key :cloud_id, :clouds
      String :name, :null => false
      DateTime :last_modified, :null => false
      unique ([:cloud_id, :name])
    end

    @db.create_table :aws_bill_line_items do
      foreign_key :aws_bill_id, :aws_bills
      Integer :line_number, :null => false

      # InvoiceID,PayerAccountId,LinkedAccountId,RecordType,RecordID,BillingPeriodStartDate,BillingPeriodEndDate,InvoiceDate,PayerAccountName,LinkedAccountName,TaxationAddress,PayerPONumber,ProductCode,ProductName,SellerOfRecord,UsageType,Operation,RateId,ItemDescription,UsageStartDate,UsageEndDate,UsageQuantity,BlendedRate,CurrencyCode,CostBeforeTax,Credits,TaxAmount,TaxType,TotalCost
      String :invoice_id
      String :payer_account_id
      String :linked_account_id
      String :record_type
      String :record_id
      DateTime :billing_period_start_date
      DateTime :billing_period_end_date
      DateTime :invoice_date
      String :payer_account_name
      String :linked_account_name
      String :taxation_address
      String :payer_po_number
      String :product_code
      String :product_name
      String :seller_of_record
      String :usage_type
      String :operation
      String :rate_id
      String :item_description
      DateTime :usage_start_date
      DateTime :usage_end_date
      Float :usage_quantity
      Float :blended_rate
      String :currency_code
      Float :cost_before_tax
      Float :credits
      Float :tax_amount
      String :tax_type
      Float :total_cost
      String :availability_zone
      HStore :tags
    end

    @db.create_view(:active_reservations, "select region, logical_az, instance_type, sum(instance_count) as instance_count, fixed_price, usage_price, duration
from reservations
where now() < end_time
group by region, logical_az, instance_type, fixed_price, usage_price, duration;")

  @db.create_view(:instance_costs, "
WITH
running AS (
  SELECT instance_type, region, logical_az, count(instances.*) AS instance_count
  FROM instances
  WHERE running = true
  GROUP BY region, logical_az, instance_type
),
reserved AS (
  SELECT logical_az, instance_type, sum(instance_count) AS instance_count
  FROM active_reservations
  GROUP BY logical_az, instance_type
),
usage AS (
  SELECT running.region, running.logical_az, running.instance_type, running.instance_count AS total_running, coalesce(reserved.instance_count,0) AS total_reserved,
    least(running.instance_count, coalesce(reserved.instance_count,0)) AS running_reserved,
    running.instance_count - least(running.instance_count, coalesce(reserved.instance_count,0)) AS running_ondemand
  FROM running
    LEFT JOIN reserved USING (logical_az, instance_type)
),
reserved_costs_raw AS (
  select region, instance_type, logical_az, running_reserved, instance_count AS reservations_at_this_price, usage_price,
    fixed_price,
    duration,
    greatest(0,least(instance_count, running_reserved - coalesce(sum(instance_count) OVER previous_matching_reservations,0))) AS instances
  from usage
    inner join active_reservations using (region, logical_az, instance_type)
  where running_reserved > 0
  window previous_matching_reservations AS (PARTITION BY region, logical_az, instance_type ORDER BY usage_price ASC ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING)

),
reserved_costs AS (
  select region, logical_az, instance_type, sum(instances) AS instances,
    usage_price AS hourly_cost_per_instance,
    fixed_price / (duration/2628000) AS monthly_ri_amort_per_instance
  from reserved_costs_raw
  group by region, logical_az, instance_type, hourly_cost_per_instance, monthly_ri_amort_per_instance
),
ondemand_costs AS (
  select region, logical_az, instance_type, sum(running_ondemand) AS instances,
    instance_ondemand_prices.price AS hourly_cost_per_instance,
    0 AS monthly_cost_per_instance
  from usage
    left join instance_ondemand_prices USING (instance_type, region)
  where running_ondemand > 0
  group by region, logical_az, instance_type, instance_ondemand_prices.price
),
merged_costs AS (
  select *, 'reserved' as pricing from reserved_costs
    UNION ALL
  select *, 'ondemand' as pricing from ondemand_costs
)
SELECT * from merged_costs
WHERE instances > 0;
")

  end
end

case ARGV.first
when 'console'
  $controller = Controller.new
  ARGV.clear
  IRB.start
when 'poll'
  Controller.new.poll_clouds(ARGV[1..-1])
when 'poll-forever'
  Controller.new.poll_forever
when 'get-prices'
  Controller.new.import_pricelist
when 'initdb'
  Controller.new.initdb
when 'migrate-db'
  Controller.new.migratedb
when 'sync-devclouds'
  Controller.new.sync_devclouds
when 'web'
  Controller.new.web
else
  raise "Unknown command"
end
